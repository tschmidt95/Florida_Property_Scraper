name: Notify on monitor-failure (v2)

on:
  issues:
    types: [opened, labeled]
  workflow_dispatch:

permissions:
  issues: read

jobs:
  notify:
    runs-on: ubuntu-latest

    steps:
      - name: "Guard: only run for issues labeled 'monitor-failure' or workflow_dispatch"
        run: |
          if [ "${GITHUB_EVENT_NAME}" = "issues" ]; then
            if ! jq -r ' .issue.labels[]?.name ' "${GITHUB_EVENT_PATH}" | grep -qx 'monitor-failure'; then
              echo "Not a monitor-failure issue; skipping."
              exit 0
            fi
          elif [ "${GITHUB_EVENT_NAME}" != "workflow_dispatch" ]; then
            echo "Not an issues or workflow_dispatch event; skipping."
            exit 0
          fi

      - name: Determine provider and webhook
        run: |
      - name: Determine provider and webhook
        run: |
          # Use ALERT_PROVIDER secret to select payload format (slack|teams|generic). Default to slack.
          PROVIDER="${{ secrets.ALERT_PROVIDER }}"
          if [ -z "$PROVIDER" ]; then
            PROVIDER=slack
          fi

          if [ -z "${{ secrets.ALERT_WEBHOOK_URL }}" ]; then
            echo "No ALERT_WEBHOOK_URL is configured. This is a template placeholder; add the secret to enable notifications."
            exit 0
          fi

          echo "PROVIDER=$PROVIDER" >> $GITHUB_ENV
          echo "WEBHOOK_URL=${{ secrets.ALERT_WEBHOOK_URL }}" >> $GITHUB_ENV

      - name: "Optional: send test payload to ALERT_WEBHOOK_URL_TEST"
        if: ${{ secrets.ALERT_WEBHOOK_URL_TEST != '' }}
        run: |
          set -euo pipefail
          TEST_URL='${{ secrets.ALERT_WEBHOOK_URL_TEST }}'
          echo 'Sending test payload to ALERT_WEBHOOK_URL_TEST...'
          payload=$(jq -n --arg repo "${{ github.repository }}" --arg issue "${{ github.event.issue.html_url || github.event.inputs.issue_url }}" '{test: true, repo: $repo, issue: $issue, note: "Test alert from notify template"}')
          RESP_FILE="/tmp/notify_test_resp_$$.txt"

          # Retry loop with exponential backoff
          MAX_ATTEMPTS=3
          SLEEP=2
          STATUS_CODE=0
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS_CODE=$(curl -sS -w "%{http_code}" -o "$RESP_FILE" -X POST -H 'Content-Type: application/json' -d "$payload" "$TEST_URL" || echo 000)
            echo "Attempt $i returned $STATUS_CODE"
            if [ "$STATUS_CODE" -ge 200 ] && [ "$STATUS_CODE" -lt 300 ]; then
              echo "Test webhook succeeded on attempt $i"
              break
            fi
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Sleeping $SLEEP seconds before retry..."
              sleep $SLEEP
              SLEEP=$(( SLEEP * 2 ))
            fi
          done

          echo "Final test webhook response status: $STATUS_CODE"
          echo "Test response body (first 500 chars):"
          head -c 500 "$RESP_FILE" || true

      - name: Build and send notification payload
        run: |
          set -euo pipefail
          ISSUE_URL="${{ github.event.issue.html_url || github.event.inputs.issue_url }}"
          ISSUE_TITLE="${{ github.event.issue.title || github.event.inputs.issue_title }}"
          ISSUE_BODY_RAW="${{ github.event.issue.body || github.event.inputs.issue_body }}"
          ISSUE_BODY=$(jq -Rs . <<< "$ISSUE_BODY_RAW")

          echo "Sending notification using provider: ${{ env.PROVIDER }}"

          if [ "${{ env.PROVIDER }}" = "slack" ]; then
            payload=$(jq -n --arg title "$ISSUE_TITLE" --arg url "$ISSUE_URL" --arg body_raw "$ISSUE_BODY_RAW" --arg repo "${GITHUB_REPOSITORY}" '{blocks: [ {type: "section", text: {type: "mrkdwn", text: (":rotating_light: *" + $title + "*\n" + ($body_raw | fromjson? // $body_raw))}}, {type: "section", fields: [{type: "mrkdwn", text: ("*Repo:* " + $repo)}, {type: "mrkdwn", text: ("*Issue:* <" + $url + "|" + $title + ">")} ]}, {type: "actions", elements: [{type: "button", text: {type: "plain_text", text: "View issue"}, url: $url}]}] }')
          elif [ "${{ env.PROVIDER }}" = "teams" ]; then
            payload=$(jq -n --arg title "$ISSUE_TITLE" --arg url "$ISSUE_URL" --arg body_raw "$ISSUE_BODY_RAW" '{title: $title, text: ($body_raw | fromjson? // $body_raw), potentialAction: [{"@type": "OpenUri", name: "View issue", targets: [{os: "default", uri: $url}]}]}')
          else
            payload=$(jq -n --arg title "$ISSUE_TITLE" --arg url "$ISSUE_URL" --arg body "$ISSUE_BODY" '{alert_type: "image_monitor_failure", title: $title, url: $url, body: ($body | fromjson? // $body)}')
          fi

          RESP_FILE="/tmp/notify_resp_$$.txt"

          # Retry loop with exponential backoff
          MAX_ATTEMPTS=3
          SLEEP=2
          STATUS_CODE=0
          for i in $(seq 1 $MAX_ATTEMPTS); do
            STATUS_CODE=$(curl -sS -w "%{http_code}" -o "$RESP_FILE" -X POST -H 'Content-Type: application/json' -d "$payload" "${{ env.WEBHOOK_URL }}" || echo 000)
            echo "Attempt $i returned $STATUS_CODE"
            if [ "$STATUS_CODE" -ge 200 ] && [ "$STATUS_CODE" -lt 300 ]; then
              echo "Webhook succeeded on attempt $i"
              break
            fi
            if [ $i -lt $MAX_ATTEMPTS ]; then
              echo "Sleeping $SLEEP seconds before retry..."
              sleep $SLEEP
              SLEEP=$(( SLEEP * 2 ))
            fi
          done

          echo "Webhook response status: $STATUS_CODE"
          echo "Response body (first 500 chars):"
          head -c 500 "$RESP_FILE" || true

      - name: Upload webhook responses
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: notify-responses
          path: |
            /tmp/notify_resp_*.txt
            /tmp/notify_test_resp_*.txt

      - name: Done
        run: echo "Notification template executed (no-op if secret not provided)."